======================================
Prevalência de Objetos e Testabilidade
======================================

Introdução
==========

Há algum tempo atrás "640K deveria ser suficiente para qualquer um"[#]_. Hoje,
estações de trabalho equipadas com 1GB de RAM ou mais estão por toda a parte
e já podemos contar com servidores de tecnologia Intel [#]_ ou SUN [#]_ capazes de
endereçar 64GB de RAM. Todos esses avanços [#]_ devem ter um impacto significativo
no modo como praticamos nossa arte [#]_. Um grupo de pioneiros [#]_ liderados
originalmente por Klaus Wuestefeld [#]_ resolveu explorar as consequências
desses avanços através da hipótese de RAM ilimitada [#]_: *como você desenvolveria
um sistema se houvesse RAM suficiente para manter todos os seus objetos de negócio?*

Uma possível resposta à essa pergunta é o tópico deste artigo, divido em 
duas partes: uma apresentação de conceitos e uma demonstração prática em
estilo tutorial.

Objetos, Objetos e Objetos
--------------------------

Um parte importante da resposta (já codificada na pergunta) é a utilização
da programação orientada a objetos. Veremos adiante como a 
prevalência de objetos permite que a POO seja realizada em todo o seu potencial
em sistemas que até então eram desenvolvidos sobre um misto de modelos relacional,
procedural e orientado a objetos.

Constataremos que as questões relacionadas a desenvolver sistemas utilizando prevalência
de objetos são, na verdade, questões sobre como desenvolver sistemas orientados
a objetos.

Quem se importa?
----------------

A prevalência de objetos torna o processo de desenvolvimento mais simples
pois elimina toda a complexidade adicional comumente associada
à utilização de um banco de dados relacional:

  * esquemas de dados e blocos de código SQL que devem ser mantidos em sincronia com o modelo de objetos;
  * camadas de mapeamento objeto-relacional;
  * baixa testabilidade que inevitavelmente cria um clima de aversão a testes em todo o time de desenvolvimento;  
  * dificuldade de instalação e atualização de sistemas em produção;
  * dilemas "to stored procedure or not to stored procedure";
  * SQL;

A prevalência de objetos permite que nos expressemos sem limites artificiais,
sem barreiras conceituais a não ser aquelas impostas pela orientação
a objetos e nossa linguagem de programação preferida. A transição dos
modelos mentais a código que funciona é mais rápida. O exercício de
nossa arte se torna novamente divertido. Tudo isso contribui para mais
redução no tempo de desenvolvimento.

A utilização de objetos sempre em memória assegura uma performance
satisfatória, sem esforço, ainda que sob condições extremas. E quando, e se,
o momento de otimização chegar, os testes e expressividade adicionais
garantirão uma empreitada tranquila.

Em suma, sistemas mais confiáveis com ótima performance desenvolvidos
em menos tempo. 

É, quem se importa?

Prevalecer: continuar a existir
===============================

Quando todos os objetos são mantidos em RAM a primeiras pergunta é: o
quê acontece quando o sistema é reiniciado?

Ou, como os objetos prevalecem?

Utilizando o mecanismo de serialização de objetos embutido na plataforma
mais o design pattern [#]_ Command [#]_ é possível criar a ilusão de
um sistema sempre em memória onde nenhuma alteração é jamais perdida. Esse
efeito pode ser obtido através de um algoritmo simples: cada comando aplicado
ao sistema deve ser armazenado em um arquivo de forma sequencial, isso permite
que durante o reinício do
sistema, cada comando encontrado no arquivo seja reexecutado, levando o modelo
de objetos para exatamente o mesmo estado em que se encontrava anteriormente.
É isso justamente o que fazem o Prevayler [#]_ (para a plataforma java) e o
Bamboo.Prevalence [#]_, a implementação que investigaremos neste
artigo, para a plataforma .net. Ambas são software livre de código aberto.

Para criar sistemas prevalecentes com qualquer uma das implementações indicadas,
apenas três regras básicas devem ser seguidas:
	
	* todos os objetos envolvidos devem ser serializáveis;
	* todas as alterações ao modelo de objetos devem ser representadas por comandos (aqui entra o design pattern) também serializáveis;
	* o sistema deve ser determinístico, em outras palavras, o sistema deve sempre chegar ao mesmo estado quando exposto ao mesmo conjunto de comandos;

Veremos como tudo isso funciona durante a implementação de nosso sistema.

Pragmaticamente
===============

Para encurtar o caminho da discussão à prática, implementaremos um sistema
simples de gerenciamento do tempo gasto com tarefas em vários projetos.
O sistema irá permitir:
	
	* o cadastro de projetos nos quais estamos trabalhando, cada projeto tem um nome e uma lista de tarefas associadas;
	
	* o cadastro de tarefas em qualquer um dos projetos, cada tarefa tem um nome, uma descrição e um registro de horas trabalhadas;
	
	* o registro de um conjunto de horas trabalhadas em uma determinada tarefa, cada registro tem uma data-hora de início e uma data-hora de fim;
  
Tudo começa com a definição de nosso modelos de objetos e seu comportamento.
Em um modelo de objetos prevalecente, o objeto raíz do modelo é chamado de
sistema e sua principal responsabilidade é abrigar os outros objetos de
negócio que, pela descrição apresentada, podemos imaginar como sendo:
projeto, tarefa e registro de horas trabalhadas.

|ObjectModel.gif|

Um diagrama de classes simples para nosso modelo de objetos

Teste Um Pouco
--------------
O modelo parece adequado mas a única forma de assegurarmos que 
atende a todas as expectativas de seus usuários é testando-o. Esse é um
dos pontos onde a prevalência de objetos brilha. Ao permitir-nos a criação
de testes automatizados de forma muito simples. Seguindo a recomendação do
artigo "Test Infected"[#]_, vamos implementar nosso sistema em pequenos
ciclos "testar um pouco, codificar um pouco". Utilizaremos a ferramenta
NUnit [#]_ para a criação dos testes .Net.

Vamos começar assegurando o comportamento básico de nossas classes, o que
servirá também como exercício de arquitetura::

	using System;
	using NUnit.Framework;
	using TaskManagement.ObjectModel;
	
	namespace TaskManagement.ObjectModel.Tests
	{
		/// <summary>
		/// Testes para a classe TaskManagementSystem.
		/// </summary>
		[TestFixture]
		public class TaskManagementSystemTestCase : Assertion
		{
			protected TaskManagementSystem _system;
	
			[SetUp]
			public void SetUp()
			{
				_system = new TaskManagementSystem();
			}
	
			[Test]
			public void TestConstruct()
			{
				AssertNotNull("A coleção de projetos não pode ser nula!", _system.Projects);
				AssertEquals("A coleção de projetos deve estar vazia!", 0, _system.Projects.Count);
			}
		}
	}


.. note::
  O método *SetUp* é executado antes de cada teste
  (o atributo *SetUp* garante isso). Cada método público
  marcado com o atributo *Test* representa um teste.
 
Esse teste assegura que todas nossas expectativas sobre a classe
TaskManagementSystem, nosso sistema prevalecente, sejam cumpridas:

	* O sistema armazena uma coleção de projetos;
	* No início, a coleção de projetos está vazia;
	
E sobre o projeto? (A partir de agora apenas o corpo das classes
será incluído).
::

		Project _project;

		[SetUp]
		public void SetUp()
		{
			_project = new Project("Artigos");
		}

		[Test]
		public void TestConstruct()
		{
			AssertEquals("O projeto deve armazenar seu nome!", "Artigos", _project.Name);
			AssertNotNull("Lista de tarefas não pode ser nula!", _project.Tasks);
			AssertEquals("Lista de tarefas deve estar vazia", 0, _project.Tasks.Count);
		}


Sobre tarefa::

		protected Task _task;

		[SetUp]
		public void SetUp()
		{
			_task = new Task("Prevalência de Objetos");
		}

		[Test]
		public void TestConstruct()
		{
			AssertEquals("Tarefa deve armazenar seu nome!", "Prevalência de Objetos", _task.Name);
			AssertNotNull("Log de trabalho não pode ser nulo!", _task.WorkRecords);
			AssertEquals("Log de trabalho deve estar vazio!", 0, _task.WorkRecords.Count);
		}
		
O registro de horas::

		protected DateTime _startTime = new DateTime(2003, 6, 29, 14, 30, 0);
		
		protected DateTime _endTime = new DateTime(2003, 6, 29, 18, 56, 0);

		protected WorkRecord _record;

		[SetUp]
		public void SetUp()
		{
			_record = new WorkRecord(_startTime, _endTime);
		}

		[Test]
		public void TestConstruct()
		{
			AssertEquals("StartTime", _startTime, _record.StartTime);
			AssertEquals("EndTime", _endTime, _record.EndTime);
		}
		
		/// <summary>
		/// Assegura que WorkRecord não aceite argumentos
		/// inválidos para a hora de início e fim.
		/// </summary>
		[Test]
		[ExpectedException(typeof(ArgumentException))]
		public void TestRejectInvalidArguments()
		{
			new WorkRecord(_endTime, _startTime);
		}


Hora de codificação de nosso modelo de objetos.

Codifique Um Pouco
------------------

Nosso objetivo agora é assegurar que as classes em nosso modelo sejam
capazes de passar os testes especificados. 

O sistema::

	namespace TaskManagement.ObjectModel
	{
		/// <summary>
		/// Um sistema para gerenciamento de tarefas.
		/// </summary>
		public class TaskManagementSystem
		{
			protected ProjectCollection _projects;
	
			/// <summary>
			/// Cria um novo sistema para gerenciamento
			/// de tarefas.
			/// </summary>
			public TaskManagementSystem()
			{
				_projects = new ProjectCollection();
			}
	
			/// <summary>
			/// Cadastro de projetos.
			/// </summary>
			public ProjectCollection Projects
			{
				get
				{
					return _projects;
				}
			}
		}
	}

O projeto::

	/// <summary>
	/// Um projeto.
	/// </summary>
	public class Project
	{
		protected string _name;

		protected TaskCollection _tasks;

		/// <summary>
		/// Cria um novo projeto com o nome
		/// especificado.
		/// </summary>
		/// <param name="name"></param>
		public Project(string name)
		{
			_name = name;
			_tasks = new TaskCollection();
		}

		/// <summary>
		/// Nome deste projeto.
		/// </summary>
		public string Name
		{
			get
			{
				return _name;
			}
		}

		/// <summary>
		/// Tarefas que compõem este projeto.
		/// </summary>
		public TaskCollection Tasks
		{
			get
			{
				return _tasks;
			}
		}
	}

A tarefa::

	/// <summary>
	/// Uma tarefa.
	/// </summary>
	public class Task
	{
		protected string _name;

		protected WorkRecordCollection _workRecords;

		/// <summary>
		/// Cria uma nova tarefa com o nome
		/// especificado.
		/// </summary>
		/// <param name="name"></param>
		public Task(string name)
		{
			_name = name;
			_workRecords = new WorkRecordCollection();
		}

		/// <summary>
		/// Nome desta tarefa.
		/// </summary>
		public string Name
		{
			get
			{
				return _name;
			}
		}

		/// <summary>
		/// Registros de horas trabalhadas nesta
		/// tarefa.
		/// </summary>
		public WorkRecordCollection WorkRecords
		{
			get
			{
				return _workRecords;
			}
		}
	}

O registro de horas trabalhadas::

	/// <summary>
	/// Um registro de horas trabalhadas.
	/// </summary>
	public class WorkRecord
	{		
		protected DateTime _startTime;

		protected DateTime _endTime;

		/// <summary>
		/// Cria um novo registro para o período indicado.
		/// </summary>
		/// <param name="startTime">início do período</param>
		/// <param name="endTime">fim do período</param>
		public WorkRecord(DateTime startTime, DateTime endTime)
		{
			if (endTime < startTime)
			{
				throw new ArgumentException("A hora de fim deve ser maior que a hora de início!", "endTime");
			}

			_startTime = startTime;
			_endTime = endTime;
		}

		/// <summary>
		/// Início do período trabalhado.
		/// </summary>
		public DateTime StartTime
		{
			get
			{
				return _startTime;
			}
		}

		/// <summary>
		/// Fim do período trabalhado.
		/// </summary>
		public DateTime EndTime
		{
			get
			{
				return _endTime;
			}
		}
	}


As classes acima fazem menção a outras não apresentadas como
**ProjectCollection**, **TaskCollection**, **WorkRecordCollection**,
essas classes foram deixadas de fora do artigo por questão de legibilidade
apenas. O código integral deste projeto encontra-se na distribuição do
Bamboo.Prevalence que pode ser obtida em
http://www.sourceforge.net/projects/bbooprevalence/.

É interessante notar que, até o momento, nenhum esforço foi feito na
tentativa de garantir que nosso modelo de objetos atenda aos requisitos
de um sistema prevalecente. Isso mostra como a utilização da
prevalência de objetos é praticamente transparente (translúcida).

Adicionando Prevalência
-----------------------

Todo objeto deve ser serializável
`````````````````````````````````
Basta marcar cada uma de nossas classes como serializável. Em .net isso
é feito com o atributo *System.SerializableAttribute* [#]_.

Exemplo::

	[Serializable]
	public class TaskManagementSystem
	
Em java, através da interface *java.io.Serializable* [#]_.

Exemplo::

	public class TaskManagementSystem implements java.io.Serializable

Testar ou não estar? Eu decidi por não incluir testes assegurando que
cada uma de nossas classes é serializável e que a serialização se dá de
forma correta por economia de espaço e tempo já que o projeto
é pequeno, de curto prazo e com classes extremamente simples.

Alterações devem ser representadas por comandos
```````````````````````````````````````````````
Segundo nosso roteiro de funcionalidades iremos precisar de comandos para:

	* adicionar um projeto ao sistema;
	* adicionar uma tarefa a um projeto;
	* adicionar um registro de horas trabalhadas;

E o que são comandos? Comandos são objetos serializáveis que implementam
a interface Bamboo.Prevalence.ICommand [#]_ de um único método::

	object Execute(object system);

O método recebe como parâmetro a instância do sistema prevalecente sobre
a qual deve agir. É importante que o comando acesse o sistema através
dessa referência apenas e nunca por qualquer outro mecanismo. As
referências podem e devem ser diferentes após o reinício do sistema.

Um ponto muito importante, *comandos são transações* e
devem manifestar as propriedades ACID - atomicidade, 
consistência, isolamento e durabilidade. As implementações
são capazes de garantir o isolamento (apenas um comando é executado
por vez) e durabilidade (todo comando é escrito no log antes de
sua execução), mas a atomicidade e consistência são
de responsabilidade do comando.

Testando Comandos
.................

Os comandos também podem e devem ser testados. Para testá-los, no entanto,
precisaremos de uma instância da classe Bamboo.Prevalence.PrevalenceEngine.
A classe PrevalenceEngine é o mediador da interação entre comandos e
sistema de forma a assegurar a ilusão de um sistema sempre em
execução onde nenhuma alteração é perdida.

Para conseguir um objeto PrevalenceEngine invocamos o método
PrevalenceActivator.CreateEngine passando o tipo do sistema
(typeof(TaskManagementSystem)) e o caminho completo
para o diretório onde devem ser armazenados os arquivos de log::

	string prevalenceBase = "c:\\tasks";
	PrevalenceEngine engine = PrevalenceActivator.CreateEngine(typeof(TaskManagementSystem), prevalenceBase);

O sistema gerenciado pelo PrevalenceEngine pode ser obtido a
qualquer momento da seguinte forma::

	TaskManagement system = engine.PrevalentSystem as TaskManagementSystem;

E com um PrevalenceEngine em mãos podemos executar comandos::

	engine.ExecuteCommand(new AddProjectCommand(project));

Com algumas alterações à classe TaskManagementSystemTestCase poderemos
iniciar a criação dos testes de nossos comandos. Após a inclusão do
suporte a PrevalenceEngine, a classe fica assim::

	namespace TaskManagement.ObjectModel.Tests
	{
		/// <summary>
		/// Testes para a classe TaskManagementSystem.
		/// </summary>
		[TestFixture]
		public class TaskManagementSystemTestCase : Assertion
		{
			protected PrevalenceEngine _engine;
	
			protected TaskManagementSystem _system;
	
			[SetUp]
			public void SetUp()
			{
				// O primeiro passo é limpar qualquer resquício de
				// testes anteriores para começar com uma "base" limpa
				ClearPrevalenceBase();
	
				_engine = PrevalenceActivator.CreateEngine(typeof(TaskManagementSystem), PrevalenceBase);
				_system = _engine.PrevalentSystem as TaskManagementSystem;
			}
	
			[TearDown]
			public void TearDown()
			{
				// Caso exista um PrevalenceEngine
				// assegura que ele "tire suas mãos do log"
				// para permitir a limpeza da base
				if (null != _engine)
				{
					_engine.HandsOffOutputLog();
				}
			}
	
			[Test]
			public void TestConstruct()
			{
				AssertNotNull("A coleção de projetos não deve ser nula!", _system.Projects);
				AssertEquals("A coleção de projetos deve estar vazia!", 0, _system.Projects.Count);
			}
			
			/// <summary>
			/// Executa um comando.
			/// </summary>
			/// <param name="command"></param>
			/// <returns></returns>
			protected object ExecuteCommand(ICommand command)
			{
				return _engine.ExecuteCommand(command);
			}
	
			/// <summary>
			/// Caminho completo para o diretório onde serão
			/// armazenados arquivos de log Bamboo.Prevalence.
			/// </summary>
			protected string PrevalenceBase
			{
				get
				{
					// calcula um caminho abaixo da pasta
					// de arquivos temporários
					return Path.Combine(Path.GetTempPath(), "TaskManagementSystem");
				}
			}
	
			/// <summary>
			/// Remove o diretório PrevalenceBase caso ele exista.
			/// </summary>
			protected void ClearPrevalenceBase()
			{
				if (Directory.Exists(PrevalenceBase))
				{
					Directory.Delete(PrevalenceBase, true);
				}
			}
		}
	}


Adicionar um Projeto
....................

Teste um Pouco
~~~~~~~~~~~~~~
::

		[Test]
		public void TestAddProject()
		{
			Project project = new Project("Artigos");
			ExecuteCommand(new AddProjectCommand(project));

			AssertEquals(1, _system.Projects.Count);
			AssertSame(project, _system.Projects[0]);
		}

Codifique um Pouco
~~~~~~~~~~~~~~~~~~

Este é o comando mais simples que iremos implementar::

	using System;
	using Bamboo.Prevalence;
	using TaskManagement.ObjectModel;
	
	namespace TaskManagement.ObjectModel.Commands
	{
		/// <summary>
		/// Adiciona um projeto ao sistema.
		/// </summary>
		[Serializable]
		public class AddProjectCommand : ICommand
		{
			protected Project _project;
	
			public AddProjectCommand(Project project)
			{
				if (null == project)
				{
					throw new ArgumentNullException("project");
				}
				_project = project;
			}
	
			public object Execute(object system)
			{
				TaskManagementSystem tasksystem = (TaskManagementSystem)system;
				tasksystem.Projects.Add(_project);
				return null;
			}
		}
	}

Simples assim. 

Adicionar uma Tarefa
....................

Aqui as coisas se tornam apenas um pouco mais complicadas. Nosso comando
deve agora adicionar uma tarefa a um projeto específico. Nosso problema é
como indicar qual projeto deve ser dono da nova tarefa de forma que o comando
possa encontrá-lo durante sua execução. Importante ressaltar: os comandos
devem ser capazes de *encontrar* os objetos sobre os quais devem agir ao 
contrário de manter referências diretas (após a serialização/deserialização
do comando as referências apontarão para objetos distintos).

Como encontrar um projeto? Poderíamos utilizar seu nome, mas para isso
deveríamos assegurar que não seja possível cadastrar dois projetos
de mesmo nome.

Uma outra solução mais genericamente aplicável é utilizarmos um ID
automaticamente gerado. O algoritmo de geração do ID deve apenas
nos garantir que cada ID criado é único. O tipo *System.Guid* é perfeito
para situações como essa. Alteremos nossa classe *Project* de acordo::

	public class Project
	{
		protected Guid _id;

		protected string _name;

		protected TaskCollection _tasks;

		/// <summary>
		/// Cria um novo projeto com o nome
		/// especificado.
		/// </summary>
		/// <param name="name"></param>
		public Project(string name)
		{
			_id = Guid.NewGuid();
			_name = name;
			_tasks = new TaskCollection();
		}

		/// <summary>
		/// Identificador único deste objeto.
		/// </summary>
		public Guid ID
		{
			get
			{
				return _id;
			}
		}

O constructor da classe assegura que o objeto possua um identificador único
através da chamada *Guid.NewGuid*.

Estamos prontos para escrever nosso teste.

Teste um Pouco
~~~~~~~~~~~~~~
::

		[Test]
		public void TestAddTask()
		{
			Project project = new Project("Artigos");
			ExecuteCommand(new AddProjectCommand(project));

			Task task = new Task("Prevalência de Objetos");
			ExecuteCommand(new AddTaskCommand(project.ID, task));

			AssertEquals(1, project.Tasks.Count);
			AssertSame(task, project.Tasks[0]);
		}

O comando *AddTaskCommand* exige como primeiro parâmetro, o ID do projeto
que deve receber a nova tarefa.

Codifique um Pouco
~~~~~~~~~~~~~~~~~~

A codificação do comando é trivial::

		public object Execute(object system)

		{

			TaskManagementSystem tasksystem = (TaskManagementSystem)system;

			Project project = tasksystem.Projects[_projectID];

			project.Tasks.Add(_task);

			return null;

		}

O código acima não seria tão simples sem uma pequena ajuda da classe
*ProjectCollection*, a possibilidade de indexar a coleção através
do identificador de projeto::

		/// <summary>

		/// Retorna o projeto de identificador

		/// indicado.

		/// </summary>

		/// <exception cref="ObjectNotFoundException">

		/// caso não exista projeto algum de identificador

		/// igual ao indicado

		/// </exception>

		public Project this[Guid id]

		{

			get

			{

				foreach (Project project in InnerList)

				{

					if (id == project.ID)

					{

						return project;

					}

				}

				throw new ObjectNotFoundException(string.Format("O projeto de ID {0} não foi encontrado!", id));

			}

		}

O Resto
.......

Está disponível online. Leia, estude, comente, tente,
inspire, expire.

O sistema deve ser determinístico
`````````````````````````````````

Um sistema prevalecente deve ser fechado. Completamente
independente de agentes ou recursos externos. Arquivos, relógios, 
conexões de rede, etc, não devem ser utilizados diretamente por
comandos pois anulariam a possibilidade de restaurar o sistema
para exatamente o mesmo estado (o que aconteceria por exemplo, se
um arquivo opcional não fosse encontrado durante o reinício do
sistema mas estivesse lá quando o comando foi executado pela primeira
vez?).

Isso não significa que todos esses recursos não possam ser utilizados,
mas apenas que devem ser de forma externa ao sistema prevalecente. No
exemplo apresentado, o método *Guid.NewGuid* não poderia ser utilizado
dentro do sistema em resposta a um comando. O algoritmo de geração
de guids depende, dentre outras coisas, do clock. Como foi utilizado, 
externamente aos comandos, não representa problema algum.

Desafios
========

Mestria
-------
Assim como o músico que sente dificuldade em se expressar com seu
instrumento após algumas semanas sem ele, os praticantes de nossa
arte ainda se expressam com dificuldade sob o paradigma da orientação
a objetos. Os anos de exposição e prática da arquitetura de 3 camadas
lógicas que dissocia dados e comportamento contribuiram, sem sombra de
dúvida, para esse estado de quase alienação. Não
nos resta opção senão readquirir a mestria através da prática constante.

Expressividade
--------------
Nossas bibliotecas e linguagens de programação ainda não são expressivas
o suficiente. Muita verbosidade ainda é requeridade na 
expressão de algoritmos simples.

Exemplo: encontre o elemento p tal que o id de p seja igual ao
id procurado.

Compare o código C#::

  foreach (Project p in projects)
  {
    if (id == p.ID)
    {
      return p;
    }
  }

Com o equivalente ruby, por exemplo::

  projects.find { |p| id == p.ID }

Esse é um campo que, definitivamente, merece atenção.

Medo
----

Medo de tentar algo diferente, medo de passar por tolo.

Bem, o medo é o caminho para o lado escuro, não é?

.. [#] http://www.brainyquote.com/quotes/quotes/b/q103747.html
.. [#] http://www.intel.com/eBusiness/products/itanium/
.. [#] http://www.sun.com/processors/UltraSPARC-III/
.. [#] http://www.prevayler.org/wiki.jsp?topic=BreakthroughsInMemoryTechnology
.. [#] http://groups.yahoo.com/group/pragprog/message/1588
.. [#] http://www.prevayler.org/wiki.jsp?topic=PrevaylerPioneers
.. [#] http://www.prevayler.org/wiki.jsp?topic=KlausWuestefeld
.. [#] http://www.prevayler.org/wiki.jsp?topic=PrevalentHypothesis
.. [#] O termo em português "padrão de projeto" ainda me soa inadequado.
.. [#] http://www.c2.com/cgi/wiki?CommandPattern
.. [#] http://www.prevayler.org/
.. [#] http://bbooprevalence.sourceforge.net/
.. [#] http://junit.sourceforge.net/doc/testinfected/testing.htm
.. [#] http://www.nunit.org/
.. [#] ms-help://MS.NETFrameworkSDKv1.1/cpref/html/frlrfsystemserializableattributeclasstopic.htm
.. [#] http://java.sun.com/j2se/1.4.1/docs/api/java/io/Serializable.html
.. [#] http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/bbooprevalence/Bamboo.Prevalence/src/Bamboo.Prevalence/ICommand.cs?rev=HEAD&content-type=text/vnd.viewcvs-markup

.. |ObjectModel.gif| image:: ObjectModel.gif

